## CRC计算方法

在CRC计算时只用8个数据位，起始位及停止位，如有奇偶校验位也包括奇偶校验位，都不参与CRC计算。
CRC计算方法是：
1、 加载一值为0XFFFF的16位寄存器，此寄存器为CRC寄存器。
2、 把第一个8位二进制数据（即通讯信息帧的第一个字节）与16位的CRC寄存器的相异或，异或的结果仍存放于该CRC寄存器中。
3、 把CRC寄存器的内容右移一位，用0填补最高位，并检测移出位是0还是1。
4、 如果移出位为零，则重复第三步（再次右移一位）；如果移出位为1，CRC寄存器与0XA001进行异或。
5、 重复步骤3和4，直到右移8次，这样整个8位数据全部进行了处理。
6、 重复步骤2和5，进行通讯信息帧下一个字节的处理。
7、 将该通讯信息帧所有字节按上述步骤计算完成后，得到的16位CRC寄存器的高、低字节进行交换
8、 最后得到的CRC寄存器内容即为：CRC校验码。
————————————————
版权声明：本文为CSDN博主「xcs101」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/xcs101/article/details/105430186

```c
/****/
u16 CRC_Calculate(u8 *Address, u8 Length)
{
	unsigned char i,j;
	unsigned int CRC;

	CRC=0xFFFF;
	for(i=0;i<Length;i++)
	{
		CRC^=*Address++;
		for(j=0;j<8;j++)
		{
			if(CRC&0x01)
			{
				CRC=(CRC>>1)^0x8408;        //如果检出的是1,那就与0x8408相异或。
			}
			else
			{
				CRC>>=0x01;         //如果是0，CRC就右移一位。
			}
		}
	}
	return ~CRC;
}
```





## 从一个示例开始讲解循环校验码CRC

例： 假如原始报文为 1100 1010 101 ，其生成多项式为：X^4+ X^3+X+1,对其进行CRC编码的结果为？？

1.  需要理解CRC计算方式，执行模2运算，也即是  <u>异或运算</u>

2. 生成多项式的求解，X^4表示第4位二进制数为1，X^3表示第3位二进制数字为1，所以多项式的二进制表示为：11011

3. 在原始报文后添加多项式长度减一个0

4. 执行异或运行算  （ 相异为1，相同为0 ）

   

   ![](E:\github\Somefiles\pictures\v2-48f2963fc595ea29d7b11c2e0d92da4b_720w.webp)



CRC编码后数据为： 1100 1010 101 **0011**

验证结果是否正确，需要将CRC编码后的数据（1100 1010 101 **0011**）对多项式（11011）进行模2运算，结果是0才正确。



**模2运算：**   是一种[二进制算法](https://baike.baidu.com/item/二进制算法/6436554?fromModule=lemma_inlink)，[CRC校验](https://baike.baidu.com/item/CRC校验/3439037?fromModule=lemma_inlink)技术中的核心部分。与四则运算相同，模2运算也包括模2加法、模2减法、模2乘法、模2除法四种二进制运算。与四则运算不同的是模2运算不考虑进位和借位，模2算术是编码理论中多项式运算的基础。模2算术在其他数字领域中的应用也是很广泛的。

